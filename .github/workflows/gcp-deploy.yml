name: Deploy to GCP

on:
  push:
    branches:
      - main

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: us-central1
  VM_EXTERNAL_ID: ${{ secrets.VM_EXTERNAL_ID }}
  SPRING_DATASOURCE_DB_NAME: ${{ secrets.POSTGRES_DB }}
  SPRING_DATASOURCE_USERNAME: ${{ secrets.POSTGRES_USER }}
  SPRING_DATASOURCE_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  RABBITMQ_PORT: ${{ secrets.RABBITMQ_PORT }}
  RABBITMQ_USERNAME: ${{ secrets.RABBITMQ_USER }}
  RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD }}
  ARTIFACT_REGISTRY_REPO: online-judge-repo
  BACKEND_SERVICE_NAME: online-judge-backend
  EXECUTOR_SERVICE_NAME: online-judge-executor

jobs:
  build-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Authenticate to GCP
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v1'

      - name: Create Artifact Registry repository if it does not exist
        run: |
          gcloud artifacts repositories describe ${{ env.ARTIFACT_REGISTRY_REPO }} --location=${{ env.GCP_REGION }} || \
          gcloud artifacts repositories create ${{ env.ARTIFACT_REGISTRY_REPO }} \
            --repository-format=docker \
            --location=${{ env.GCP_REGION }} \
            --description="Docker repository for online judge"
        
      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Build and push backend image
        run: |
          docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.BACKEND_SERVICE_NAME }}:${{ github.sha }} ./backend
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.BACKEND_SERVICE_NAME }}:${{ github.sha }}

      - name: Build and push executor image
        run: |
          docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.EXECUTOR_SERVICE_NAME }}:${{ github.sha }} ./executor
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.EXECUTOR_SERVICE_NAME }}:${{ github.sha }}

  deploy-backend:
    needs: build-images
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate to GCP
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v1'

      - name: Deploy backend to Cloud Run
        run: |
          gcloud run deploy ${{ env.BACKEND_SERVICE_NAME }} \
            --image=${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.BACKEND_SERVICE_NAME }}:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --port=8080 \
            --set-env-vars="SPRING_DATASOURCE_URL=jdbc:postgresql://${{ env.VM_EXTERNAL_ID }}:5432/${{ env.SPRING_DATASOURCE_DB_NAME }},SPRING_DATASOURCE_USERNAME=${{ env.SPRING_DATASOURCE_USERNAME }},SPRING_DATASOURCE_PASSWORD=${{ env.SPRING_DATASOURCE_PASSWORD }},SPRING_DATASOURCE_DRIVER_CLASS_NAME=org.postgresql.Driver,SPRING_JPA_DATABASE_PLATFORM=org.hibernate.dialect.PostgreSQLDialect,SPRING_RABBITMQ_HOST=${{ env.VM_EXTERNAL_ID }},SPRING_RABBITMQ_PORT=${{ env.RABBITMQ_PORT }},SPRING_RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USER }},SPRING_RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}"

      - name: Wait for backend to be ready
        run: |
          echo "Waiting for backend to be ready..."
          BACKEND_URL=$(gcloud run services describe ${{ env.BACKEND_SERVICE_NAME }} --region=${{ env.GCP_REGION }} --format="value(status.url)")
          echo "Backend URL: $BACKEND_URL"
          
          # Wait for backend and RabbitMQ readiness with timeout
          TIMEOUT=300  # 5 minutes timeout
          INTERVAL=10  # Check every 10 seconds
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "Checking backend and RabbitMQ readiness... (${ELAPSED}s elapsed)"
            
            # Check custom RabbitMQ readiness endpoint
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "$BACKEND_URL/actuator/health/rabbitmq-ready" || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Backend and RabbitMQ are fully ready!"
              break
            elif [ "$HTTP_STATUS" = "503" ]; then
              echo "Backend is up but RabbitMQ not ready yet..."
            elif [ "$HTTP_STATUS" = "000" ]; then
              echo "Backend not reachable yet..."
            else
              echo "Backend returned HTTP status: $HTTP_STATUS"
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "Timeout waiting for backend to be ready"
            exit 1
          fi
          
          echo "Backend is fully ready. Proceeding with executor deployment."

  deploy-executor:
    needs: deploy-backend
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate to GCP
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v1'

      - name: Deploy executor to Cloud Run
        run: |
          gcloud run deploy ${{ env.EXECUTOR_SERVICE_NAME }} \
            --image=${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.EXECUTOR_SERVICE_NAME }}:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --set-env-vars="RABBITMQ_HOST=${{ env.VM_EXTERNAL_ID }},RABBITMQ_PORT=${{ env.RABBITMQ_PORT}},RABBITMQ_USER=${{ env.RABBITMQ_USERNAME }},RABBITMQ_PASS=${{ env.RABBITMQ_PASSWORD }}"