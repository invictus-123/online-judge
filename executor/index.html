
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docker: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">online-judge/executor/docker/runner.go (5.7%)</option>
				
				<option value="file1">online-judge/executor/master/master.go (5.9%)</option>
				
				<option value="file2">online-judge/executor/rabbitmq/rabbitmq.go (5.4%)</option>
				
				<option value="file3">online-judge/executor/testutil/testutil.go (93.9%)</option>
				
				<option value="file4">online-judge/executor/worker/worker.go (40.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package docker

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "strings"
        "time"

        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/client"
        "github.com/google/uuid"
)

// ExecutionResult holds the outcome of running code in a container.
type ExecutionResult struct {
        Output     string
        Status     string // e.g., "ACCEPTED", "WRONG_ANSWER", "TIME_LIMIT_EXCEEDED"
        TimeMillis int64
        MemoryKB   int64
}

// LanguageConfig defines the Docker image and commands for a language.
type LanguageConfig struct {
        Image      string
        SourceFile string
        CompileCmd []string
        ExecuteCmd []string
}

// A map of supported languages to their Docker configurations.
var langConfigs = map[string]LanguageConfig{
        "JAVA": {
                Image:      "openjdk:11-jdk-slim",
                SourceFile: "Main.java",
                CompileCmd: []string{"javac", "Main.java"},
                ExecuteCmd: []string{"java", "-cp", ".", "Main"},
        },
        "PYTHON": {
                Image:      "python:3.9-slim",
                SourceFile: "main.py",
                CompileCmd: nil, // Interpreted language
                ExecuteCmd: []string{"python", "main.py"},
        },
        "CPP": {
                Image:      "gcc:latest",
                SourceFile: "main.cpp",
                CompileCmd: []string{"g++", "main.cpp", "-o", "main"},
                ExecuteCmd: []string{"./main"},
        },
        // Add other languages here
}

// RunInContainer creates a Docker container, executes the code, and returns the result.
func RunInContainer(language, code, input string) (*ExecutionResult, error) <span class="cov8" title="1">{
        return RunInContainerWithLimits(0, language, code, input, 2.0, 256*1024*1024) // 2 seconds, 256MB
}</span>

// RunInContainerWithLimits creates a Docker container with custom limits, executes the code, and returns the result.
func RunInContainerWithLimits(submissionID int64, language, code, input string, timeLimitSeconds float64, memoryLimitBytes int64) (*ExecutionResult, error) <span class="cov8" title="1">{
        ctx := context.Background()
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create docker client: %w", err)
        }</span>

        <span class="cov8" title="1">config, ok := langConfigs[language]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unsupported language: %s", language)
        }</span>

        // Create a temporary directory to store the source code
        <span class="cov0" title="0">tempDir, err := ioutil.TempDir("", "online-judge-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp dir: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tempDir)

        // Write the source code to the file
        sourceFilePath := fmt.Sprintf("%s/%s", tempDir, config.SourceFile)
        if err := ioutil.WriteFile(sourceFilePath, []byte(code), 0644); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write source code: %w", err)
        }</span>

        // Pull the Docker image if it doesn't exist
        <span class="cov0" title="0">reader, err := cli.ImagePull(ctx, config.Image, types.ImagePullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to pull image %s: %w", config.Image, err)
        }</span>
        <span class="cov0" title="0">io.Copy(ioutil.Discard, reader) // Wait for pull to complete

        // Create the container with a long-running command so we can exec into it
        resp, err := cli.ContainerCreate(ctx, &amp;container.Config{
                Image:        config.Image,
                Cmd:          []string{"sleep", "300"}, // Keep container alive for 5 minutes
                WorkingDir:   "/app",
                Tty:          false,
                OpenStdin:    true,
                AttachStdout: true,
                AttachStderr: true,
        }, &amp;container.HostConfig{
                Binds: []string{fmt.Sprintf("%s:/app", tempDir)},
                Resources: container.Resources{
                        Memory: memoryLimitBytes,
                },
        }, nil, nil, "oj-"+uuid.New().String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create container: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // Ensure container is removed
                if submissionID &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("[Submission %d] Removing container %s", submissionID, resp.ID)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Removing container %s", resp.ID)
                }</span>
                <span class="cov0" title="0">if err := cli.ContainerRemove(ctx, resp.ID, types.ContainerRemoveOptions{Force: true}); err != nil </span><span class="cov0" title="0">{
                        if submissionID &gt; 0 </span><span class="cov0" title="0">{
                                log.Printf("[Submission %d] Failed to remove container %s: %v", submissionID, resp.ID, err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Failed to remove container %s: %v", resp.ID, err)
                        }</span>
                }
        }()

        // Start the container so we can execute commands in it
        <span class="cov0" title="0">if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start container: %w", err)
        }</span>

        // --- COMPILE STEP ---
        <span class="cov0" title="0">if config.CompileCmd != nil </span><span class="cov0" title="0">{
                if submissionID &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("[Submission %d] Compiling code in container %s", submissionID, resp.ID)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Compiling code in container %s", resp.ID)
                }</span>
                <span class="cov0" title="0">execConfig := types.ExecConfig{
                        Cmd:          config.CompileCmd,
                        AttachStdout: true,
                        AttachStderr: true,
                }
                execID, err := cli.ContainerExecCreate(ctx, resp.ID, execConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create compile exec: %w", err)
                }</span>

                <span class="cov0" title="0">execResp, err := cli.ContainerExecAttach(ctx, execID.ID, types.ExecStartCheck{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to attach to compile exec: %w", err)
                }</span>
                <span class="cov0" title="0">defer execResp.Close()

                if err := cli.ContainerExecStart(ctx, execID.ID, types.ExecStartCheck{}); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start compile exec: %w", err)
                }</span>

                // Check compilation result
                <span class="cov0" title="0">inspect, err := cli.ContainerExecInspect(ctx, execID.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to inspect compile exec: %w", err)
                }</span>

                <span class="cov0" title="0">if inspect.ExitCode != 0 </span><span class="cov0" title="0">{
                        var compileErr bytes.Buffer
                        io.Copy(&amp;compileErr, execResp.Reader)
                        return &amp;ExecutionResult{
                                Status:     "COMPILATION_ERROR",
                                Output:     compileErr.String(),
                                TimeMillis: 0,
                                MemoryKB:   0,
                        }, nil
                }</span>

                // For C++, make the executable file executable
                <span class="cov0" title="0">if language == "CPP" </span><span class="cov0" title="0">{
                        chmodConfig := types.ExecConfig{
                                Cmd:          []string{"chmod", "+x", "main"},
                                AttachStdout: false,
                                AttachStderr: false,
                        }
                        chmodExecID, err := cli.ContainerExecCreate(ctx, resp.ID, chmodConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create chmod exec: %w", err)
                        }</span>
                        
                        <span class="cov0" title="0">if err := cli.ContainerExecStart(ctx, chmodExecID.ID, types.ExecStartCheck{}); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to start chmod exec: %w", err)
                        }</span>
                }
        }

        // --- EXECUTION STEP ---
        // Execute the program using docker exec
        <span class="cov0" title="0">if submissionID &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("[Submission %d] Executing code in container %s", submissionID, resp.ID)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Executing code in container %s", resp.ID)
        }</span>
        <span class="cov0" title="0">execConfig := types.ExecConfig{
                Cmd:          config.ExecuteCmd,
                AttachStdin:  true,
                AttachStdout: true,
                AttachStderr: true,
        }
        execID, err := cli.ContainerExecCreate(ctx, resp.ID, execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create execution exec: %w", err)
        }</span>

        <span class="cov0" title="0">execResp, err := cli.ContainerExecAttach(ctx, execID.ID, types.ExecStartCheck{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to attach to execution exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execResp.Close()

        // Start execution
        if err := cli.ContainerExecStart(ctx, execID.ID, types.ExecStartCheck{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start execution exec: %w", err)
        }</span>

        // Write input to stdin
        <span class="cov0" title="0">_, err = execResp.Conn.Write([]byte(input))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write to stdin: %w", err)
        }</span>
        <span class="cov0" title="0">execResp.CloseWrite() // Close stdin to signal end of input

        startTime := time.Now()
        var outputBuffer bytes.Buffer
        var memoryUsageKB int64

        // Start memory monitoring
        memoryDone := make(chan int64)
        go func() </span><span class="cov0" title="0">{
                var maxMemory uint64 = 1024 * 1024 // Default 1MB in bytes
                
                // Monitor for a maximum duration to prevent hanging
                timeout := time.After(time.Duration(timeLimitSeconds*1.5) * time.Second)
                ticker := time.NewTicker(10 * time.Millisecond)
                defer ticker.Stop()
                
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-timeout:<span class="cov0" title="0">
                                memoryDone &lt;- int64(maxMemory / 1024)
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                stats, err := cli.ContainerStats(ctx, resp.ID, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span> // Continue monitoring on error
                                }
                                <span class="cov0" title="0">var statsData types.StatsJSON
                                if err := json.NewDecoder(stats.Body).Decode(&amp;statsData); err != nil </span><span class="cov0" title="0">{
                                        stats.Body.Close()
                                        continue</span> // Continue monitoring on decode error
                                }
                                <span class="cov0" title="0">stats.Body.Close()
                                
                                if statsData.MemoryStats.Usage &gt; 0 &amp;&amp; statsData.MemoryStats.Usage &gt; maxMemory </span><span class="cov0" title="0">{
                                        maxMemory = statsData.MemoryStats.Usage
                                }</span>
                        }
                }
        }()

        // Read output with timeout
        <span class="cov0" title="0">done := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                io.Copy(&amp;outputBuffer, execResp.Reader)
                done &lt;- true
        }</span>()

        <span class="cov0" title="0">timeLimit := time.Duration(timeLimitSeconds * float64(time.Second))
        var timedOut bool
        select </span>{
        case &lt;-time.After(timeLimit):<span class="cov0" title="0">
                cli.ContainerKill(ctx, resp.ID, "SIGKILL")
                timedOut = true</span>
        case &lt;-done:<span class="cov0" title="0"></span>
                // Execution completed, check exit code
        }

        // Wait for memory monitoring to complete
        <span class="cov0" title="0">memoryUsageKB = &lt;-memoryDone
        if memoryUsageKB &lt;= 0 </span><span class="cov0" title="0">{
                memoryUsageKB = 1024 // Default to 1MB if we can't measure
        }</span>

        <span class="cov0" title="0">execTime := time.Since(startTime)

        if timedOut </span><span class="cov0" title="0">{
                return &amp;ExecutionResult{
                        Status:     "TIME_LIMIT_EXCEEDED",
                        Output:     outputBuffer.String(),
                        TimeMillis: execTime.Milliseconds(),
                        MemoryKB:   memoryUsageKB,
                }, nil
        }</span>

        // Check execution result
        <span class="cov0" title="0">inspect, err := cli.ContainerExecInspect(ctx, execID.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inspect execution exec: %w", err)
        }</span>

        <span class="cov0" title="0">if inspect.ExitCode != 0 </span><span class="cov0" title="0">{
                return &amp;ExecutionResult{
                        Status:     "RUNTIME_ERROR",
                        Output:     outputBuffer.String(),
                        TimeMillis: execTime.Milliseconds(),
                        MemoryKB:   memoryUsageKB,
                }, nil
        }</span>
        
        // Check memory limit
        <span class="cov0" title="0">if memoryUsageKB*1024 &gt; memoryLimitBytes </span><span class="cov0" title="0">{
                return &amp;ExecutionResult{
                        Status:     "MEMORY_LIMIT_EXCEEDED",
                        Output:     strings.TrimSpace(outputBuffer.String()),
                        TimeMillis: execTime.Milliseconds(),
                        MemoryKB:   memoryUsageKB,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;ExecutionResult{
                Status:     "ACCEPTED",
                Output:     strings.TrimSpace(outputBuffer.String()),
                TimeMillis: execTime.Milliseconds(),
                MemoryKB:   memoryUsageKB,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package master

import (
        "encoding/json"
        "log"
        "online-judge/executor/rabbitmq"
        "online-judge/executor/types"
        "online-judge/executor/worker"

        "github.com/rabbitmq/amqp091-go"
)

type Master struct {
        mqClient    rabbitmq.ClientInterface
        jobQueue    chan amqp091.Delivery
        workerCount int
        queueName   string
}

func NewMaster(mqClient rabbitmq.ClientInterface, workerCount int, queueName string) (*Master, error) <span class="cov8" title="1">{
        return &amp;Master{
                mqClient:    mqClient,
                jobQueue:    make(chan amqp091.Delivery, workerCount),
                workerCount: workerCount,
                queueName:   queueName,
        }, nil
}</span>

func (m *Master) Start() <span class="cov0" title="0">{
        for workerID := 1; workerID &lt;= m.workerCount; workerID++ </span><span class="cov0" title="0">{
                worker := worker.NewWorker(workerID, m.jobQueue, m.mqClient)
                go worker.Start()
        }</span>

        <span class="cov0" title="0">go m.consumeAndDispatch()</span>
}

func (m *Master) consumeAndDispatch() <span class="cov0" title="0">{
        msgs, err := m.mqClient.ConsumeSubmissions(m.queueName)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start consuming submissions: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Master is waiting for submissions on queue '%s'. To exit press CTRL+C", m.queueName)

        for d := range msgs </span><span class="cov0" title="0">{
                var submission types.SubmissionMessage
                if err := json.Unmarshal(d.Body, &amp;submission); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error deserializing submission: %v. Rejecting message.", err)
                        d.Ack(false) // Ack the malformed request
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("[Submission %d] Received submission. Dispatching to a worker.", submission.SubmissionID)
                m.jobQueue &lt;- d</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rabbitmq

import (
        "encoding/json"
        "fmt"
        "log"

        "github.com/rabbitmq/amqp091-go"
)

// Exchange and Routing Key constants, must match the Java backend configuration.
const (
        ResultExchange   = "oj.ex.results"
        ResultRoutingKey = "submission.result"
        StatusExchange   = "oj.ex.status"
        StatusRoutingKey = "submission.status"
)

type ClientInterface interface {
        ConsumeSubmissions(queueName string) (&lt;-chan amqp091.Delivery, error)
        Publish(exchange, routingKey string, body interface{}) error
}

type Client struct {
        conn *amqp091.Connection
        ch   *amqp091.Channel
}

func NewClient(url string) (*Client, error) <span class="cov0" title="0">{
        conn, err := amqp091.Dial(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
        }</span>

        <span class="cov0" title="0">ch, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to open a channel: %w", err)
        }</span>

        // Declare exchanges to ensure they exist.
        <span class="cov0" title="0">err = ch.ExchangeDeclare(
                ResultExchange,
                "direct", // kind
                true,     // durable
                false,    // autoDelete
                false,    // internal
                false,    // noWait
                nil,      // args
        )
        if err != nil </span><span class="cov0" title="0">{
                ch.Close()
                conn.Close()
                return nil, fmt.Errorf("failed to declare result exchange: %w", err)
        }</span>

        <span class="cov0" title="0">err = ch.ExchangeDeclare(
                StatusExchange,
                "direct", // kind
                true,     // durable
                false,    // autoDelete
                false,    // internal
                false,    // noWait
                nil,      // args
        )
        if err != nil </span><span class="cov0" title="0">{
                ch.Close()
                conn.Close()
                return nil, fmt.Errorf("failed to declare status exchange: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{conn: conn, ch: ch}, nil</span>
}

func (c *Client) ConsumeSubmissions(queueName string) (&lt;-chan amqp091.Delivery, error) <span class="cov0" title="0">{
        err := c.ch.Qos(
                1,     // prefetchCount: Each worker gets one message at a time.
                0,     // prefetchSize
                false, // global
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set QoS: %w", err)
        }</span>

        <span class="cov0" title="0">msgs, err := c.ch.Consume(
                queueName,
                "",    // consumer
                false, // auto-ack: messages will be manually acked in the worker
                false, // exclusive
                false, // no-local
                false, // no-wait
                nil,   // args
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register a consumer: %w", err)
        }</span>
        <span class="cov0" title="0">return msgs, nil</span>
}

func (c *Client) Publish(exchange, routingKey string, body interface{}) error <span class="cov0" title="0">{
        jsonBody, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal body to JSON: %w", err)
        }</span>

        <span class="cov0" title="0">err = c.ch.Publish(
                exchange,
                routingKey,
                false, // mandatory
                false, // immediate
                amqp091.Publishing{
                        ContentType:  "application/json",
                        DeliveryMode: amqp091.Persistent,
                        Body:         jsonBody,
                })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish a message: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Published message to exchange '%s' with key '%s'", exchange, routingKey)
        return nil</span>
}

func (c *Client) Close() <span class="cov8" title="1">{
        if c.ch != nil </span><span class="cov0" title="0">{
                c.ch.Close()
        }</span>
        <span class="cov8" title="1">if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package testutil

import (
        "encoding/base64"
        "encoding/json"
        "online-judge/executor/types"

        "github.com/rabbitmq/amqp091-go"
)

func CreateTestSubmission(submissionID int64, language, code string, timeLimit float64, memoryLimit int64, testCases []TestCase) types.SubmissionMessage <span class="cov8" title="1">{
        var testCaseMessages []types.TestCaseMessage
        for _, tc := range testCases </span><span class="cov8" title="1">{
                testCaseMessages = append(testCaseMessages, types.TestCaseMessage{
                        TestCaseID:     tc.ID,
                        Input:          base64.StdEncoding.EncodeToString([]byte(tc.Input)),
                        ExpectedOutput: base64.StdEncoding.EncodeToString([]byte(tc.ExpectedOutput)),
                })
        }</span>

        <span class="cov8" title="1">return types.SubmissionMessage{
                SubmissionID: submissionID,
                Language:     language,
                Code:         base64.StdEncoding.EncodeToString([]byte(code)),
                TimeLimit:    timeLimit,
                MemoryLimit:  memoryLimit,
                TestCases:    testCaseMessages,
        }</span>
}

type TestCase struct {
        ID             string
        Input          string
        ExpectedOutput string
}

func CreateTestDelivery(submission types.SubmissionMessage) amqp091.Delivery <span class="cov8" title="1">{
        data, _ := json.Marshal(submission)
        return amqp091.Delivery{Body: data}
}</span>

func CreateSimpleTestCase(id, input, expectedOutput string) TestCase <span class="cov8" title="1">{
        return TestCase{
                ID:             id,
                Input:          input,
                ExpectedOutput: expectedOutput,
        }
}</span>

func CreatePythonHelloWorldSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                1,
                "PYTHON",
                "print('Hello, World!')",
                2.0,
                128,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "Hello, World!"),
                },
        )
}</span>

func CreateJavaHelloWorldSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        javaCode := `public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}`
        return CreateTestSubmission(
                2,
                "JAVA",
                javaCode,
                3.0,
                256,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "Hello, World!"),
                },
        )
}</span>

func CreateCppHelloWorldSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        cppCode := `#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
    return 0;
}`
        return CreateTestSubmission(
                3,
                "CPP",
                cppCode,
                2.5,
                512,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "Hello, World!"),
                },
        )
}</span>

func CreateAdditionSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                4,
                "PYTHON",
                "print(int(input()) + int(input()))",
                1.0,
                64,
                []TestCase{
                        CreateSimpleTestCase("tc1", "1\n2", "3"),
                        CreateSimpleTestCase("tc2", "5\n7", "12"),
                        CreateSimpleTestCase("tc3", "0\n0", "0"),
                },
        )
}</span>

func CreateInfiniteLoopSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                5,
                "PYTHON",
                "while True: pass",
                0.5,
                128,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "should timeout"),
                },
        )
}</span>

func CreateCompilationErrorSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                6,
                "JAVA",
                "invalid java code without main method",
                2.0,
                256,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "should not compile"),
                },
        )
}</span>

func CreateRuntimeErrorSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        pythonCode := `
arr = [1, 2, 3]
print(arr[10])  # Index out of bounds
`
        return CreateTestSubmission(
                7,
                "PYTHON",
                pythonCode,
                2.0,
                128,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "should crash"),
                },
        )
}</span>

func CreateWrongAnswerSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                8,
                "PYTHON",
                "print('Wrong Answer')",
                1.0,
                64,
                []TestCase{
                        CreateSimpleTestCase("tc1", "", "Correct Answer"),
                },
        )
}</span>

func CreateMultipleTestCasesSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return CreateTestSubmission(
                9,
                "PYTHON",
                "print(input().upper())",
                1.5,
                128,
                []TestCase{
                        CreateSimpleTestCase("tc1", "hello", "HELLO"),
                        CreateSimpleTestCase("tc2", "world", "WORLD"),
                        CreateSimpleTestCase("tc3", "test", "TEST"),
                        CreateSimpleTestCase("tc4", "python", "PYTHON"),
                },
        )
}</span>

func CreateFibonacciSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        pythonCode := `
n = int(input())
if n &lt;= 1:
    print(n)
else:
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    print(b)
`
        return CreateTestSubmission(
                10,
                "PYTHON",
                pythonCode,
                3.0,
                256,
                []TestCase{
                        CreateSimpleTestCase("tc1", "0", "0"),
                        CreateSimpleTestCase("tc2", "1", "1"),
                        CreateSimpleTestCase("tc3", "5", "5"),
                        CreateSimpleTestCase("tc4", "10", "55"),
                },
        )
}</span>

func CreateMixedResultsSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        pythonCode := `
n = int(input())
if n == 1:
    print("one")
elif n == 2:
    print("two")
elif n == 3:
    print("wrong")
else:
    print("unknown")
`
        return CreateTestSubmission(
                11,
                "PYTHON",
                pythonCode,
                2.0,
                128,
                []TestCase{
                        CreateSimpleTestCase("tc1", "1", "one"),
                        CreateSimpleTestCase("tc2", "2", "two"),
                        CreateSimpleTestCase("tc3", "3", "three"),
                        CreateSimpleTestCase("tc4", "4", "unknown"),
                },
        )
}</span>

func CreateLargeInputSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        pythonCode := `
import sys
total = 0
for line in sys.stdin:
    total += int(line.strip())
print(total)
`
        largeInput := ""
        for i := 1; i &lt;= 1000; i++ </span><span class="cov8" title="1">{
                largeInput += "1\n"
        }</span>
        
        <span class="cov8" title="1">return CreateTestSubmission(
                12,
                "PYTHON",
                pythonCode,
                5.0,
                512,
                []TestCase{
                        CreateSimpleTestCase("tc1", largeInput, "1000"),
                },
        )</span>
}

type ExpectedResult struct {
        OverallStatus string
        TestCaseResults map[string]string
        ShouldHaveTime bool
        ShouldHaveMemory bool
}

func AssertSubmissionResult(result types.ResultNotificationMessage, expected ExpectedResult) bool <span class="cov8" title="1">{
        if result.Status != expected.OverallStatus </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">if len(result.Results) != len(expected.TestCaseResults) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">for _, tcResult := range result.Results </span><span class="cov8" title="1">{
                expectedStatus, exists := expected.TestCaseResults[tcResult.TestCaseID]
                if !exists || tcResult.Status != expectedStatus </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">if expected.ShouldHaveTime &amp;&amp; result.TimeTaken &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">if expected.ShouldHaveMemory &amp;&amp; result.MemoryUsed &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">return true</span>
}

func ExpectAllPassed(testCaseIDs []string) ExpectedResult <span class="cov8" title="1">{
        results := make(map[string]string)
        for _, id := range testCaseIDs </span><span class="cov8" title="1">{
                results[id] = "PASSED"
        }</span>
        <span class="cov8" title="1">return ExpectedResult{
                OverallStatus:    "PASSED",
                TestCaseResults:  results,
                ShouldHaveTime:   true,
                ShouldHaveMemory: true,
        }</span>
}

func ExpectWrongAnswer(testCaseIDs []string, wrongCaseID string) ExpectedResult <span class="cov8" title="1">{
        results := make(map[string]string)
        for _, id := range testCaseIDs </span><span class="cov8" title="1">{
                if id == wrongCaseID </span><span class="cov8" title="1">{
                        results[id] = "WRONG_ANSWER"
                }</span> else<span class="cov8" title="1"> {
                        results[id] = "PASSED"
                }</span>
        }
        <span class="cov8" title="1">return ExpectedResult{
                OverallStatus:    "WRONG_ANSWER",
                TestCaseResults:  results,
                ShouldHaveTime:   true,
                ShouldHaveMemory: true,
        }</span>
}

func ExpectTimeLimit(testCaseIDs []string) ExpectedResult <span class="cov8" title="1">{
        results := make(map[string]string)
        for _, id := range testCaseIDs </span><span class="cov8" title="1">{
                results[id] = "TIME_LIMIT_EXCEEDED"
        }</span>
        <span class="cov8" title="1">return ExpectedResult{
                OverallStatus:    "TIME_LIMIT_EXCEEDED",
                TestCaseResults:  results,
                ShouldHaveTime:   true,
                ShouldHaveMemory: false,
        }</span>
}

func ExpectCompilationError(testCaseIDs []string) ExpectedResult <span class="cov8" title="1">{
        results := make(map[string]string)
        for _, id := range testCaseIDs </span><span class="cov8" title="1">{
                results[id] = "COMPILATION_ERROR"
        }</span>
        <span class="cov8" title="1">return ExpectedResult{
                OverallStatus:    "COMPILATION_ERROR",
                TestCaseResults:  results,
                ShouldHaveTime:   false,
                ShouldHaveMemory: false,
        }</span>
}

func ExpectRuntimeError(testCaseIDs []string) ExpectedResult <span class="cov8" title="1">{
        results := make(map[string]string)
        for _, id := range testCaseIDs </span><span class="cov8" title="1">{
                results[id] = "RUNTIME_ERROR"
        }</span>
        <span class="cov8" title="1">return ExpectedResult{
                OverallStatus:    "RUNTIME_ERROR",
                TestCaseResults:  results,
                ShouldHaveTime:   true,
                ShouldHaveMemory: true,
        }</span>
}

func CreateInvalidBase64Submission() types.SubmissionMessage <span class="cov8" title="1">{
        return types.SubmissionMessage{
                SubmissionID: 999,
                Language:     "PYTHON",
                Code:         "invalid-base64-code",
                TimeLimit:    1.0,
                MemoryLimit:  128,
                TestCases: []types.TestCaseMessage{
                        {
                                TestCaseID:     "tc1",
                                Input:          base64.StdEncoding.EncodeToString([]byte("")),
                                ExpectedOutput: base64.StdEncoding.EncodeToString([]byte("output")),
                        },
                },
        }
}</span>

func CreateInvalidInputSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return types.SubmissionMessage{
                SubmissionID: 998,
                Language:     "PYTHON",
                Code:         base64.StdEncoding.EncodeToString([]byte("print('hello')")),
                TimeLimit:    1.0,
                MemoryLimit:  128,
                TestCases: []types.TestCaseMessage{
                        {
                                TestCaseID:     "tc1",
                                Input:          "invalid-base64-input",
                                ExpectedOutput: base64.StdEncoding.EncodeToString([]byte("hello")),
                        },
                },
        }
}</span>

func CreateInvalidOutputSubmission() types.SubmissionMessage <span class="cov8" title="1">{
        return types.SubmissionMessage{
                SubmissionID: 997,
                Language:     "PYTHON",
                Code:         base64.StdEncoding.EncodeToString([]byte("print('hello')")),
                TimeLimit:    1.0,
                MemoryLimit:  128,
                TestCases: []types.TestCaseMessage{
                        {
                                TestCaseID:     "tc1",
                                Input:          base64.StdEncoding.EncodeToString([]byte("")),
                                ExpectedOutput: "invalid-base64-output",
                        },
                },
        }
}</pre>
		
		<pre class="file" id="file4" style="display: none">package worker

import (
        "encoding/base64"
        "encoding/json"
        "log"
        "online-judge/executor/docker"
        "online-judge/executor/rabbitmq"
        "online-judge/executor/types"
        "strings"

        "github.com/rabbitmq/amqp091-go"
)

type Worker struct {
        id       int
        jobQueue &lt;-chan amqp091.Delivery
        mqClient rabbitmq.ClientInterface
}

func NewWorker(id int, jobQueue &lt;-chan amqp091.Delivery, mqClient rabbitmq.ClientInterface) *Worker <span class="cov0" title="0">{
        return &amp;Worker{
                id:       id,
                jobQueue: jobQueue,
                mqClient: mqClient,
        }
}</span>

func (w *Worker) Start() <span class="cov0" title="0">{
        for job := range w.jobQueue </span><span class="cov0" title="0">{
                w.process(job)
        }</span>
}

func (w *Worker) process(job amqp091.Delivery) <span class="cov0" title="0">{
        var submission types.SubmissionMessage
        if err := json.Unmarshal(job.Body, &amp;submission); err != nil </span><span class="cov0" title="0">{
                log.Printf("[Worker %d] Error deserializing submission: %v. Rejecting message.", w.id, err)
                job.Nack(false, false) // Nack and send to DLQ
                return
        }</span>
        <span class="cov0" title="0">log.Printf("[Submission %d] [Worker %d] Processing submission.", submission.SubmissionID, w.id)

        if err := updateStatus(submission.SubmissionID, "RUNNING", w); err != nil </span><span class="cov0" title="0">{
                log.Printf("[Submission %d] [Worker %d] Failed to publish running status: %v", submission.SubmissionID, w.id, err)
                // We will continue processing but NACK at the end if results also fail to publish.
        }</span>

        // 2. Execute all test cases
        <span class="cov0" title="0">decodedCode, err := base64.StdEncoding.DecodeString(submission.Code)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Submission %d] [Worker %d] Failed to decode submission code: %v. Rejecting message.", submission.SubmissionID, w.id, err)
                job.Ack(false) // Ack the message as there is no point executing further with a malformed code
                return
        }</span>
        <span class="cov0" title="0">var results []types.TestCaseResultMessage
        for _, testCase := range submission.TestCases </span><span class="cov0" title="0">{
                log.Printf("[Submission %d] [Worker %d] Running test case %s.", submission.SubmissionID, w.id, testCase.TestCaseID)

                decodedInput, err := base64.StdEncoding.DecodeString(testCase.Input)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Submission %d] [Worker %d] Failed to decode test case input %s: %v. Failing this test case.", submission.SubmissionID, w.id, testCase.TestCaseID, err)
                        results = append(results, types.TestCaseResultMessage{
                                TestCaseID: testCase.TestCaseID,
                                Status:     "COMPILATION_ERROR",
                                Output:     base64.StdEncoding.EncodeToString([]byte("Invalid Base64 for test case input.")),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">memoryLimitBytes := submission.MemoryLimit * 1024 * 1024 // Convert MB to bytes
                execResult, err := docker.RunInContainerWithLimits(submission.SubmissionID, submission.Language, string(decodedCode), string(decodedInput), submission.TimeLimit, memoryLimitBytes)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Submission %d] [Worker %d] Execution failed for test case %s: %v", submission.SubmissionID, w.id, testCase.TestCaseID, err)
                        results = append(results, types.TestCaseResultMessage{
                                TestCaseID: testCase.TestCaseID,
                                Status:     "COMPILATION_ERROR",
                                Output:     base64.StdEncoding.EncodeToString([]byte(err.Error())),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">decodedExpectedOutput, err := base64.StdEncoding.DecodeString(testCase.ExpectedOutput)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[Submission %d] [Worker %d] Failed to decode expected output for test case %s: %v", submission.SubmissionID, w.id, testCase.TestCaseID, err)
                        results = append(results, types.TestCaseResultMessage{
                                TestCaseID: testCase.TestCaseID,
                                Status:     "COMPILATION_ERROR",
                                Output:     base64.StdEncoding.EncodeToString([]byte("Invalid Base64 for expected output.")),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">status := computeTestCaseStatus(execResult, string(decodedExpectedOutput))
                
                results = append(results, types.TestCaseResultMessage{
                        TestCaseID: testCase.TestCaseID,
                        Output:     base64.StdEncoding.EncodeToString([]byte(execResult.Output)),
                        Status:     status,
                        TimeTaken:  float64(execResult.TimeMillis) / 1000,
                        MemoryUsed: execResult.MemoryKB,
                })</span>
        }

        <span class="cov0" title="0">if err := sendResults(submission.SubmissionID, results, w); err != nil </span><span class="cov0" title="0">{
                log.Printf("[Submission %d] [Worker %d] Failed to publish results: %v. NACKing message.", submission.SubmissionID, w.id, err)
                job.Nack(false, true) // Nack and requeue, as results failed to send
                return
        }</span>

        // 4. Acknowledge the message from the submission queue as processing is complete.
        <span class="cov0" title="0">job.Ack(false)
        log.Printf("[Submission %d] [Worker %d] Finished processing submission.", submission.SubmissionID, w.id)</span>
}

func sendResults(submissionID int64, results []types.TestCaseResultMessage, w *Worker) error <span class="cov0" title="0">{
        overallStatus, maxTime, maxMemory := computeOverallStatus(results)
        
        resultNotification := types.ResultNotificationMessage{
                SubmissionID: submissionID,
                Status:       overallStatus,
                TimeTaken:    maxTime,
                MemoryUsed:   maxMemory,
                Results:      results,
        }
        return w.mqClient.Publish(rabbitmq.ResultExchange, rabbitmq.ResultRoutingKey, resultNotification)
}</span>

func updateStatus(submissionID int64, status string, w *Worker) error <span class="cov0" title="0">{
        statusUpdate := types.StatusUpdateMessage{
                SubmissionID: submissionID,
                Status:       status,
        }
        return w.mqClient.Publish(rabbitmq.StatusExchange, rabbitmq.StatusRoutingKey, statusUpdate)
}</span>

func computeTestCaseStatus(execResult *docker.ExecutionResult, expectedOutput string) string <span class="cov8" title="1">{
        if execResult.Status == "TIME_LIMIT_EXCEEDED" </span><span class="cov8" title="1">{
                return "TIME_LIMIT_EXCEEDED"
        }</span>
        <span class="cov8" title="1">if execResult.Status == "COMPILATION_ERROR" </span><span class="cov8" title="1">{
                return "COMPILATION_ERROR"
        }</span>
        <span class="cov8" title="1">if execResult.Status == "RUNTIME_ERROR" </span><span class="cov8" title="1">{
                return "RUNTIME_ERROR"
        }</span>
        
        <span class="cov8" title="1">actualOutput := strings.TrimSpace(execResult.Output)
        expectedOutput = strings.TrimSpace(expectedOutput)
        
        if actualOutput == expectedOutput </span><span class="cov8" title="1">{
                return "PASSED"
        }</span>
        <span class="cov8" title="1">return "WRONG_ANSWER"</span>
}

func computeOverallStatus(results []types.TestCaseResultMessage) (string, float64, int64) <span class="cov8" title="1">{
        if len(results) == 0 </span><span class="cov8" title="1">{
                return "COMPILATION_ERROR", 0.0, 0
        }</span>
        
        <span class="cov8" title="1">var maxTime float64
        var maxMemory int64
        overallStatus := "PASSED"
        
        for _, result := range results </span><span class="cov8" title="1">{
                if result.TimeTaken &gt; maxTime </span><span class="cov8" title="1">{
                        maxTime = result.TimeTaken
                }</span>
                <span class="cov8" title="1">if result.MemoryUsed &gt; maxMemory </span><span class="cov8" title="1">{
                        maxMemory = result.MemoryUsed
                }</span>
                
                <span class="cov8" title="1">if result.Status == "COMPILATION_ERROR" </span><span class="cov8" title="1">{
                        overallStatus = "COMPILATION_ERROR"
                }</span> else<span class="cov8" title="1"> if result.Status == "RUNTIME_ERROR" &amp;&amp; overallStatus == "PASSED" </span><span class="cov8" title="1">{
                        overallStatus = "RUNTIME_ERROR"
                }</span> else<span class="cov8" title="1"> if result.Status == "TIME_LIMIT_EXCEEDED" &amp;&amp; (overallStatus == "PASSED" || overallStatus == "WRONG_ANSWER") </span><span class="cov8" title="1">{
                        overallStatus = "TIME_LIMIT_EXCEEDED"
                }</span> else<span class="cov8" title="1"> if result.Status == "MEMORY_LIMIT_EXCEEDED" &amp;&amp; (overallStatus == "PASSED" || overallStatus == "WRONG_ANSWER") </span><span class="cov8" title="1">{
                        overallStatus = "MEMORY_LIMIT_EXCEEDED"
                }</span> else<span class="cov8" title="1"> if result.Status == "WRONG_ANSWER" &amp;&amp; overallStatus == "PASSED" </span><span class="cov8" title="1">{
                        overallStatus = "WRONG_ANSWER"
                }</span>
        }
        
        <span class="cov8" title="1">return overallStatus, maxTime, maxMemory</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
